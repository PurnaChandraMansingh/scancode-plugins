#!/usr/bin/env python3
# Copyright (c) nexB Inc.
# Copyright (c) 2016-2019 Christoph Reiter
#
# Based on MSYS2 web application code.
# download_url: https://raw.githubusercontent.com/msys2/msys2-web/628ec96975ab84b4e13567c8d4bdc25ad1a8f937/main.py

# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

"""
Utility to keep Windows prebuilt ScanCode toolkit plugins up to date.

This library fetches an msys2 binary package archive and then fetches all its
recursive binary and source packages dependencies. Archives are then extracted.
Finally a configured subset of the files (e.g. dlls, licenses, etc) are installed
in a target directory of a plugin.

Note that the file formats are the same as for ArchLinux.

A Windows packages repository from MSYS2 is essentially an Archlinux AUR/pacman
repository.

Theory of operations:
We start by collecting package index pages and get the URLs to all packages
Then we process the root package found in the index:
 - fetch, extract, install and same for its source
 - repeat this for each dependency

- we only deal with 64 bits packages and ignore 32 bits
- there are msys packages (built with Cygwin) and mingw packages (standalone)
- for each of these we have sources and binaries
- for each of these sources and binaries, we have an index in a repo at http://repo.msys2.org/:
  - either as an HTML directory listing of archives
  - or as .db file which is a tar.gz tarball that contains one directory per
    latest version of a package with a desc file
- each archive contains the payload of installable files and some metadata:
    - for binaries: .PKGINFO: key=value pairs, same as archlinux
    See     # https://wiki.archlinux.org/index.php/User:Apg#String_List_Fields
    - for sources: .SRCINFO: key=value pairs, same as archlinux
    See https://wiki.archlinux.org/index.php/.SRCINFO
    -  Both are generated by makepkg
    - other such as (.BUILDINFO, .MTREE) of no interest for now.

- each archive also has a <archive name>.sig file with a PGP signature for
  verification.

Of note: a tarball can be compressed with gzip, xz, or zstd.
"""

from collections import defaultdict
from distutils.dir_util import copy_tree
import functools
from itertools import zip_longest
import os
import re
import shutil
import sys

import attr

import shared_utils

#
REQUEST_TIMEOUT = 60

TRACE = False
TRACE_DEEP = False
TRACE_FETCH = False
TRACE_INSTALL = False

CACHE_DIR = 'src-msys2'

################################################################################
# Package repositories
################################################################################


@attr.attributes
class Repository:
    """
    A repository is a collection of package binaries and sources.
    """

    binaries_url = attr.ib(
        type=str,
        metadata=dict(help='URL to HTML listing of package binaries such as http://repo.msys2.org/mingw/x86_64'),
    )

    sources_url = attr.ib(
        type=str,
        metadata=dict(help='URL to HTML listing of package sources http://repo.msys2.org/mingw/sources'),
    )

    binaries_by_name = attr.ib(
        type=dict,
        default=attr.Factory(lambda: defaultdict(list)),
        metadata=dict(help=
            'Mapping of {package name: [list of BinaryPackage versions]} available in this repo'),
    )
    sources_by_name = attr.ib(
        type=dict,
        default=attr.Factory(lambda: defaultdict(list)),
        metadata=dict(help=
            'Mapping of {package name: [list of SourcePackage versions]} available in this repo'),
    )

    def populate_package_from_index_urls(self):
        """
        Populate BinaryPackage and SourcePackage in this repo.
        Caches the fetched indexes for the duration of a session.
        """
        print(f'Loading Repo from HTML indexes at: {self.binaries_url} and: {self.sources_url}')

        def populate_index(index_url, package_cls):
            by_name = defaultdict(list)
            download_urls = find_download_urls(index_url)
            for download_url, file_name in download_urls:
                pck = package_cls.from_download_url(download_url, file_name)
                by_name[pck.name].append(pck)
            for _name, versions in by_name.items():
                BasePackage.sort(versions)
            return by_name

        self.sources_by_name = populate_index(index_url=self.sources_url, package_cls=SourcePackage)
        self.binaries_by_name = populate_index(index_url=self.binaries_url, package_cls=BinaryPackage)

    @classmethod
    def update_packages(self, existing_packages, new_packages):
        """
        Update an index mapping of {name: [packages]}
        """

    def populate_package_from_directory(self):
        """
        Populate BinaryPackage and SourcePackage in this repo.
        Caches the fetched indexes for the duration of a session.
        """
        print(f'Loading Repo from HTML indexes at: {self.binaries_url} and: {self.sources_url}')

        source_download_urls = find_download_urls(self.sources_url)
        for download_url, file_name in source_download_urls:
            sp = SourcePackage.from_download_url(download_url, file_name)
            self.sources_by_name[sp.name].append(sp)

        binary_download_urls = find_download_urls(self.binaries_url)
        for download_url, file_name in binary_download_urls:
            bp = BinaryPackage.from_download_url(download_url, file_name)
            self.binaries_by_name[bp.name].append(bp)

        # sort each list of package for a name by version from oldest to newest
        for _name, versions in self.binaries_by_name.items():
            BasePackage.sort(versions)

        for _name, versions in self.sources_by_name.items():
            BasePackage.sort(versions)

    def get_binary_package_version(self, name, version=None):
        """
        Return the binary Package with name and version or None.
        Return the latest version if version is None
        """
        packages = self.binaries_by_name.get(name)
        return self.get_package_version(packages, name, version)

    def get_source_package_version(self, name, version=None):
        """
        Return the source Package with name and version or None.
        Return the latest version if version is None
        """
        packages = self.sources_by_name.get(name)
        return self.get_package_version(packages, name, version)

    @classmethod
    def get_package_version(cls, packages, name, version=None):
        """
        Return the Package with name and version from packages or None.
        Return the latest version if version is None.
        """
        if not packages:
            return
        if len(packages) == 1:
            return packages[0]
        if not version:
            return packages[-1]
        for p in packages:
            if p.version == version:
                return p


EXTENSIONS = '.tar.gz', '.tar.bz2', '.zip', '.tar.xz', '.sig'


def find_download_urls(repo_url, cache_dir=CACHE_DIR, extensions=EXTENSIONS):
    """
    Return a list of tuples (download URL, filename) for hrefs found in the HTML
    age index at `repo_url`that match the list of `extensions` strings.
    """
    get_hrefs = re.compile('href="([^"]+)"').findall

    _, _, index_file_name = repo_url.partition('//')
    index_file_name = index_file_name.strip('/').replace('/', '-') + '.html'

    index_loc = shared_utils.fetch_file(
        url=repo_url,
        dir_location=cache_dir,
        file_name=index_file_name,
        force=False,
    )

    with open(index_loc) as fi:
        text = fi.read()

    hrefs = get_hrefs(text)
    hrefs = [l for l in hrefs if l.endswith(extensions)]
    return  [(f'{repo_url}/{href}', href) for href in hrefs]


REPOSITORIES = {
    'mingw64': Repository(
        # vcs_url='https://github.com/msys2/MINGW-packages',
        binaries_url='http://repo.msys2.org/mingw/x86_64',
        sources_url='http://repo.msys2.org/mingw/sources',
    ),
    'msys64': Repository(
        # vcs_url='https://github.com/msys2/MSYS2-packages',
        binaries_url='http://repo.msys2.org/msys/x86_64',
        sources_url='http://repo.msys2.org/msys/sources',
    ),
}

################################################################################
# Packages and archives
################################################################################

SOURCE_TYPE = '.src.'
BINARY_TYPE = '.pkg.'


@attr.attributes(auto_attribs=True)
class PackageName:
    """
    All the parts of a package name extracted from a source or binary package filename.
    """
    prefix: str
    name: str
    vcs: str
    epoch: str
    version: str
    release: str
    arch: str
    ptype: str
    extension: str

    @property
    def real_name(self):
        return  f'{self.name}-{self.vcs}' if self.vcs else self.name

    @property
    def full_name(self):
        return f'{self.prefix}{self.real_name}'

    @property
    def full_version(self):
        version = self.version
        if self.epoch:
            version = f'{self.epoch}~{version}'
        return  f'{version}-{self.release}'

    @classmethod
    def parse_version(cls, version):
        """
        Parse a version string in a string tuple if (epoch, version, release).

        For example::
        >>> PackageName.parse_version('1.0.8-1')
        ('', '1.0.8', '1')
        >>> PackageName.parse_version('1.0.8')
        ('', '1.0.8', '')
        >>> PackageName.parse_version('2~1.0.8')
        ('2', '1.0.8', '')
        >>> PackageName.parse_version('4~1.0.8foo-2')
        ('4', '1.0.8foo', '2')
        """
        epoch, _, vr = version.rpartition('~')
        version, _, release = vr.partition('-')
        return epoch, version, release

    @property
    def file_name(self):
        """
        Return a file_name reconstructed from parts.

        For example::

        >>> names = '''mingw-w64-x86_64-bzip2-1.0.8-1-any.pkg.tar.xz
        ... mingw-w64-x86_64-ca-certificates-20200601-1-any.pkg.tar.zst
        ... mingw-w64-x86_64-expat-2.2.9-1-any.pkg.tar.xz
        ... mingw-w64-x86_64-file-5.39-1-any.pkg.tar.zst
        ... mingw-w64-x86_64-gcc-libs-10.2.0-3-any.pkg.tar.zst
        ... mingw-w64-x86_64-gettext-0.19.8.1-9-any.pkg.tar.zst
        ... mingw-w64-x86_64-gmp-6.2.0-1-any.pkg.tar.xz
        ... mingw-w64-x86_64-libarchive-3.4.3-1-any.pkg.tar.zst
        ... mingw-w64-x86_64-libffi-3.3-1-any.pkg.tar.xz
        ... mingw-w64-x86_64-libiconv-1.16-1-any.pkg.tar.xz
        ... mingw-w64-x86_64-libsystre-1.0.1-4-any.pkg.tar.xz
        ... mingw-w64-x86_64-libtasn1-4.16.0-1-any.pkg.tar.xz
        ... mingw-w64-x86_64-libtre-git-r128.6fb7206-2-any.pkg.tar.xz
        ... mingw-w64-x86_64-libwinpthread-git-8.0.0.5906.c9a21571-1-any.pkg.tar.zst
        ... mingw-w64-x86_64-lz4-1.9.2-1-any.pkg.tar.xz
        ... mingw-w64-x86_64-mpc-1.2.0-1-any.pkg.tar.zst
        ... mingw-w64-x86_64-mpfr-4.1.0-2-any.pkg.tar.zst
        ... mingw-w64-x86_64-nettle-3.6-1-any.pkg.tar.zst
        ... mingw-w64-x86_64-openssl-1.1.1.g-1-any.pkg.tar.xz
        ... mingw-w64-x86_64-p11-kit-0.23.20-2-any.pkg.tar.xz
        ... mingw-w64-bzip2-1.0.8-1.src.tar.gz
        ... mingw-w64-ca-certificates-20200601-1.src.tar.gz
        ... mingw-w64-expat-2.2.9-1.src.tar.gz
        ... mingw-w64-file-5.39-1.src.tar.gz
        ... mingw-w64-gcc-10.2.0-3.src.tar.gz
        ... mingw-w64-gettext-0.19.8.1-9.src.tar.gz
        ... mingw-w64-gmp-6.2.0-1.src.tar.gz
        ... mingw-w64-libarchive-3.4.3-1.src.tar.gz
        ... mingw-w64-libffi-3.3-1.src.tar.gz
        ... mingw-w64-libiconv-1.16-1.src.tar.gz
        ... mingw-w64-libsystre-1.0.1-4.src.tar.gz
        ... mingw-w64-libtasn1-4.16.0-1.src.tar.gz
        ... mingw-w64-libtre-git-r128.6fb7206-2.src.tar.gz
        ... mingw-w64-lz4-1.9.2-1.src.tar.gz
        ... mingw-w64-mpc-1.2.0-1.src.tar.gz
        ... mingw-w64-mpfr-4.1.0-2.src.tar.gz
        ... mingw-w64-nettle-3.6-1.src.tar.gz
        ... mingw-w64-openssl-1.1.1.g-1.src.tar.gz
        ... mingw-w64-p11-kit-0.23.20-2.src.tar.gz
        ... mingw-w64-winpthreads-git-8.0.0.5906.c9a21571-1.src.tar.gz
        ... mingw-w64-xz-5.2.5-1.src.tar.gz
        ... mingw-w64-zlib-1.2.11-7.src.tar.gz
        ... mingw-w64-zstd-1.4.5-1.src.tar.gz
        ... mingw-w64-x86_64-xz-5.2.5-1-any.pkg.tar.xz
        ... mingw-w64-x86_64-zlib-1.2.11-7-any.pkg.tar.xz
        ... mingw-w64-x86_64-zstd-1.4.5-1-any.pkg.tar.zst'''.split()

        >>> for fn in names:
        ...     pfn = PackageName.from_file_name(fn)
        ...     assert fn == pfn.file_name, (pfn, pfn.file_name)
        """

        arch = f'-{self.arch}' if self.arch else ''
        return (
            f'{self.full_name}-{self.full_version}{arch}{self.ptype}{self.extension}')

    @classmethod
    def from_file_name(cls, file_name):
        """
        Return a (prefix, name, epoch, vcs, version, release, arch, ptype, extension) tuple
        parsed from a `file_name`.

        For example::

        >>> PackageName.from_file_name('mingw-w64-x86_64-docbook-xml-1~4.5-1-any.pkg.tar.xz')
        PackageName(prefix='mingw-w64-x86_64-', name='docbook-xml', vcs='', epoch='1', version='4.5', release='1', arch='any', ptype='.pkg.', extension='tar.xz')
        >>> PackageName.from_file_name('parallel-20191022-1-any.pkg.tar.xz')
        PackageName(prefix='', name='parallel', vcs='', epoch='', version='20191022', release='1', arch='any', ptype='.pkg.', extension='tar.xz')
        >>> PackageName.from_file_name('mingw-w64-docbook-xml-1~4.5-1.src.tar.gz')
        PackageName(prefix='mingw-w64-', name='docbook-xml', vcs='', epoch='1', version='4.5', release='1', arch='', ptype='.src.', extension='tar.gz')
        >>> PackageName.from_file_name('base-2020.05-2-any.pkg.tar.zst')
        PackageName(prefix='', name='base', vcs='', epoch='', version='2020.05', release='2', arch='any', ptype='.pkg.', extension='tar.zst')
        >>> PackageName.from_file_name('msys2-launcher-git-0.3.32.56c2ba7-2.src.tar.gz')
        PackageName(prefix='', name='msys2-launcher', vcs='git', epoch='', version='0.3.32.56c2ba7', release='2', arch='', ptype='.src.', extension='tar.gz')
        >>> PackageName.from_file_name('mingw-w64-x86_64-libtre-git-r128.6fb7206-2-any.pkg.tar.xz')
        PackageName(prefix='mingw-w64-x86_64-', name='libtre', vcs='git', epoch='', version='r128.6fb7206', release='2', arch='any', ptype='.pkg.', extension='tar.xz')
        >>> PackageName.from_file_name('mingw-w64-x86_64-libwinpthread-git-8.0.0.5906.c9a21571-1-any.pkg.tar.zst')
        PackageName(prefix='mingw-w64-x86_64-', name='libwinpthread', vcs='git', epoch='', version='8.0.0.5906.c9a21571', release='1', arch='any', ptype='.pkg.', extension='tar.zst')
        >>> PackageName.from_file_name('mingw-w64-x86_64-firebird2-git-2.5.9.27149.9f6840e90c-1-any.pkg.tar.xz')
        PackageName(prefix='mingw-w64-x86_64-', name='firebird2', vcs='git', epoch='', version='2.5.9.27149.9f6840e90c', release='1', arch='any', ptype='.pkg.', extension='tar.xz')
        """
        if not any(pt in file_name for pt in (SOURCE_TYPE, BINARY_TYPE)):
            raise Exception(f'Unknown file_name format: {file_name}')

        PTYPE = SOURCE_TYPE if SOURCE_TYPE in file_name else BINARY_TYPE

        if file_name.startswith('mingw-w64-x86_64-'):
            _, prefix, file_name = file_name.partition('mingw-w64-x86_64-')

        elif file_name.startswith('mingw-w64-'):
            _, prefix, file_name = file_name.partition('mingw-w64-')

        else:
            prefix = ''

        nevra, ptype, extension = file_name.partition(PTYPE)
        if ptype == BINARY_TYPE:
            nevr, _, arch = nevra.rpartition('-')
        else:
            # no arch for sources
            arch = ''
            nevr = nevra

        if '~' in nevr:
            ne, _, vr = nevr.partition('~')
            name, _, epoch = ne.rpartition('-')
            version, _, release = vr.rpartition('-')
        else:
            # no epoch
            epoch = ''
            nv, _, release = nevr.rpartition('-')
            name, _, version = nv.rpartition('-')

        if name.endswith('-git'):
            name, _, vcs = name.rpartition('-')
        else:
            vcs = ''

        return cls(
            prefix=prefix,
            name=name,
            vcs=vcs,
            epoch=epoch,
            version=version,
            release=release,
            arch=arch,
            ptype=ptype,
            extension=extension,
        )


def get_full_version(package_data):
    """
    Given a mapping of package_data that contains a version and may an epoch and
    release, return a complete version.

    For example::
    >>> get_full_version(dict(version='1.2.3'))
    '1.2.3'
    >>> get_full_version(dict(version='1.2.3', epoch='2'))
    '2~1.2.3'
    >>> get_full_version(dict(version='1.2.3', epoch='2', release='23'))
    '2~1.2.3-23'
    """
    version = package_data['version']

    release = package_data.get('release', '')
    if release:
        release = f'-{release}'

    epoch = package_data.get('epoch', '')
    if epoch:
        epoch = f'{epoch}~'

    version = f'{epoch}{version}{release}'
    return version


def filter_unknown_attributes(cls, package_data):
    """
    Given a  mapping of package_data, return a new mapping of package_data that
    contains only known `cls` attr class attributes.
    """
    known_fields = attr.fields_dict(cls)
    return {
        key: value for key, value in package_data.items()
        if key in known_fields
    }


@attr.attributes(kw_only=True)
class BasePackage:

    name = attr.ib(
        type=str,
        metadata=dict(
            help='Package name.'),
    )

    version = attr.ib(
        type=str,
        metadata=dict(
            help='Package version.'),
    )

    base = attr.ib(
        type=str,
        metadata=dict(
            help='Package base name: the name of the source package'),
    )

    download_url = attr.ib(
        type=str,
        metadata=dict(help='Download URL'),
    )

    arch = attr.ib(
        default='any',
        type=str,
        metadata=dict(
            help='Package architecture. Mostly unused in mingw e.g. "any". Used for msys.'),
    )

    desc = attr.ib(type=str, default=None, metadata=dict(help='description'))
    url = attr.ib(type=str, default=None, metadata=dict(help='home url'))
    licenses = attr.ib(type=list, default=attr.Factory(list), metadata=dict(help='licenses'))

    @property
    def file_name(self):
        return shared_utils.file_name_from_url(self.download_url)

    @property
    def real_name(self):
        pn = PackageName.from_file_name(self.file_name)
        return pn.real_name

    def to_about(self):
        """
        Return an ABOUT data mapping
        """
        return dict(
            about_resource=self.file_name,
            type='msys2',
            name=self.name,
            version=self.version,
            download_url=self.download_url,
            description=self.desc,
            homepage_url=self.url,
            declared_license=self.licenses,
        )

    @classmethod
    def sort(cls, packages):
        """
        Sort a list of `packages` in place by version.
        All package are assumed to have the same name.
        """
        if not packages or len(packages) == 1:
            return packages

        packages.sort(key=lambda p: version_sort_key(p.version))

    def update_with_package(self, package):
        """
        Update package with a `package` object.
        """
        for field in attr.fields_dict(self.__class__):
            value = getattr(self, field)
            new_value = getattr(package, field)
            if new_value and not value:
                setattr(self, field, new_value)

    def update_with_package_data(self, package_data):
        """
        Update package with a `package_data` mapping.
        """
        new_package = self.from_package_data(package_data)
        self.update_with_package(new_package)

    def update_with_info(self, pkginfo_or_srcinfo_location):
        """
        Update self with data found in the .PKGINFO or .SRCINFO file at
        `pkginfo_or_srcinfo_location`
        """
        with open(pkginfo_or_srcinfo_location) as fi:
            text = fi.read()
        pkgdata = parse_pkginfo(text)
        self.update_with_package_data(package_data=pkgdata)

    @classmethod
    def prepare_package_data(cls, package_data):
        """
        Return a new mapping of package_data by filtering and adjusting existing
        package data for use with `cls` class
        """
        version = get_full_version(package_data)
        package_data['version'] = version

        # the base is the source package name if present
        package_data['base'] = package_data.get('base') or package_data['name']

        package_data = filter_unknown_attributes(cls, package_data)

        return package_data


@attr.attributes(kw_only=True)
class SourcePackage(BasePackage):

    binary_package_name = attr.ib(
        type=str,
        metadata=dict(
            help='Package name.'),
    )

    @classmethod
    def from_download_url(cls, download_url):
        """
        Return a SourcePackage built from a download URL.
        """
        file_name = shared_utils.file_name_from_url(download_url)
        pn = PackageName.from_file_name(file_name)
        return cls(
            name=pn.full_name,
            binary_package_name=None,
            version=pn.full_version,
            arch=pn.arch or 'any',
            download_url=download_url,
        )

    @classmethod
    def from_package_data(cls, package_data, download_url=None):
        """
        Return a new `SourcePackage` object built from a `package_data` mapping.
        """
        package_data = cls.prepare_package_data(package_data)
        package_data['download_url'] = download_url

        # the base is the source package name if present
        binary_package_name = package_data['name']
        package_data['name'] = package_data['base']
        return cls(binary_package_name=binary_package_name, **package_data)


@attr.attributes(kw_only=True)
class BinaryPackage(BasePackage):

    source_package_name = attr.ib(type=str, metadata=dict(help='Source Package name'),)

    groups = attr.ib(type=list, default=attr.Factory(list), metadata=dict(help='groups'))
    sha256 = attr.ib(type=str, default=None, metadata=dict(help='sha256'))

    depends = attr.ib(type=list, default=attr.Factory(list), metadata=dict(help='depends'))
    makedepends = attr.ib(type=list, default=attr.Factory(list), metadata=dict(help='makedepends'))
    checkdepends = attr.ib(type=list, default=attr.Factory(list), metadata=dict(help='checkdepends'))
    optdepends = attr.ib(type=list, default=attr.Factory(list), metadata=dict(help='optdepends'))
    provides = attr.ib(type=list, default=attr.Factory(list), metadata=dict(help='provides'))

    conflicts = attr.ib(type=list, default=attr.Factory(list), metadata=dict(help='conflicts'))
    replaces = attr.ib(type=list, default=attr.Factory(list), metadata=dict(help='replaces'))

    def __attrs_post_init__(self):
        self.depends = self.split_depends(self.depends)
        self.makedepends = self.split_depends(self.makedepends)
        self.checkdepends = self.split_depends(self.checkdepends)
        self.optdepends = self.split_opt(self.optdepends)
        self.provides = dict(self.split_depends(self.provides))

    @classmethod
    def from_package_data(cls, package_data, download_url=None):
        """
        Return a BinaryPackage built from a package data mapping (from a desc or
        pkginfo file).
        """
        package_data = cls.prepare_package_data(package_data)
        package_data['download_url'] = download_url
        return cls(source_package_name=package_data['base'], **package_data)

    @classmethod
    def from_download_url(cls, download_url):
        """
        Return a BinaryPackage built from a download URL.
        """
        file_name = shared_utils.file_name_from_url(download_url)
        pn = PackageName.from_file_name(file_name)
        return cls(
            name=pn.full_name,
            version=pn.full_version,
            arch=pn.arch or 'any',
            download_url=download_url,
            source_package_name=None,
        )

    def get_all_dependencies(self, repo):
        """
        Yield recursively all the dependent packages of this package in a repo.
        """
        for dep_name, dep_req in self.depends:
            try:
                name = dep_name
                repo.binaries_by_name[name]
            except KeyError:
                name = dep_name + '-git'
                repo.binaries_by_name[name]

            # TODO: use/apply dep_req to select correct version
            latest_depp = repo.get_binary_package_version(name)
            if not latest_depp:
                raise Exception('Unable to find latest version for:', name)

            yield latest_depp

            for subdep in latest_depp.get_all_dependencies(repo):
                yield subdep

    def get_unique_dependencies(self, repo):
        """
        Return a list of unique dependent packages of this package in a repo.
        """
        unique = {}
        for dep in self.get_all_dependencies(repo):
            if dep.name not in unique:
                unique[dep.name] = dep
        return sorted(unique.values())

    @classmethod
    def split_depends(cls, deps):
        """
        Given a list of dependencies each as a string, return a list of (dep
        name, dep constraint) tuples.
        """
        r = []
        for d in deps:
            parts = re.split('([<>=]+)', d, 1)
            first = parts[0].strip()
            second = ''.join(parts[1:]).strip()
            r.append((first, second))
        return r

    @classmethod
    def split_opt(cls, deps):
        """
        Given a list of optional dependencies each as a string, return a list of (dep
        name, dep constraint) tuples.
        """
        r = []
        for d in deps:
            if ':' in d:
                a, b = d.split(':', 1)
                r.append((a.strip(), b.strip()))
            else:
                r.append((d.strip(), ''))
        return r

################################################################################
# Parse package manifests
################################################################################


def parse_desc(text):
    """
    Parse a description text and return a mapping of {key: values}.
    For instance:

        %FILENAME%
        mingw-w64-x86_64-gcc-9.3.0-2-any.pkg.tar.xz

        %DEPENDS%
        mingw-w64-x86_64-crt
        mingw-w64-x86_64-headers

    will yield:
        {
        '%FILENAME%': ['mingw-w64-x86_64-gcc-9.3.0-2-any.pkg.tar.xz'],
        '%DEPENDS%': [ 'mingw-w64-x86_64-crt','mingw-w64-x86_64-headers']
        }
    """

    parsed = defaultdict(list)
    key = None
    values = []
    for line in text.splitlines():
        line = line.strip()
        if key is None:
            key = line
        elif not line:
            # an empty line means the end of values for that key and the start
            # of a new one
            parsed[key] = values
            key = None
            values = []
        else:
            values.append(line)
    if key is not None:
        parsed[key] = values

    # https://wiki.archlinux.org/index.php/User:Apg#String_List_Fields
    string_list_fields = (
        '%GROUPS%',
        '%LICENSE%',
        '%FILES%',
        '%DEPENDS%',
        '%PROVIDES%',
        '%CONFLICTS%',
        '%REPLACES%',
        '%OPTDEPENDS%',
        '%MAKEDEPENDS%',
        '%CHECKDEPENDS%',
    )

    for key, value in list(parsed.items()):
        if key in string_list_fields:
            parsed[key] = value[0]

    return normalize_package_data_keys(parsed)


# https://wiki.archlinux.org/index.php/User:Apg#String_List_Fields
STRING_LIST_FIELDS = (
    'group',
    'license',
    'depend',
    'depends',
    'optdepend',
    'optdepends',
    'makedepend',
    'makedepends',
    'checkdepend',
    'checkdepends',
    'conflict',
    'conflicts',
    'replaces',
    'provides',
    # .BUILDINFO
    'buildenv',
    'options',
    'installed',
    # .SRCINFO
    'source',
    'md5sums',
    'sha1sums',
    'sha224sums',
    'sha256sums',
    'sha384sums',
    'sha512sums',
)


def parse_pkginfo(text, string_list_fields=STRING_LIST_FIELDS):
    """
    Parse text from a .PKGINFO found in a binary package root.
    See https://wiki.archlinux.org/index.php/User:Apg#.PKGINFO for details
    Can also parse .SRCINFO files.

    For example, a .PKGINFO:
    >>> text = '''
    ... # Generated by makepkg 5.2.2
    ... pkgname = mingw-w64-x86_64-sqlcipher
    ... pkgbase = mingw-w64-sqlcipher
    ... pkgver = 4.4.2-1
    ... license = GPL
    ... pkgdesc = SQLite extension
    ... url = https://www.zetetic.net/sqlcipher/
    ... builddate = 1607372620
    ... packager = CI (msys2-autobuild/00f7657c/406699447)
    ... size = 5267906
    ... arch = any
    ... license = BSD
    ... depend = mingw-w64-x86_64-gcc-libs
    ... depend = mingw-w64-x86_64-openssl
    ... depend = mingw-w64-x86_64-readline
    ... makedepend = mingw-w64-x86_64-tcl'''
    >>> expected = {
    ...     'name': 'mingw-w64-x86_64-sqlcipher',
    ...     'base': 'mingw-w64-sqlcipher',
    ...     'version': '4.4.2-1',
    ...     'licenses': ['GPL', 'BSD'],
    ...     'desc': 'SQLite extension',
    ...     'url': 'https://www.zetetic.net/sqlcipher/',
    ...     'builddate': '1607372620',
    ...     'packager': 'CI (msys2-autobuild/00f7657c/406699447)',
    ...     'size': '5267906',
    ...     'arch': 'any',
    ...     'depends': [
    ...         'mingw-w64-x86_64-gcc-libs',
    ...         'mingw-w64-x86_64-openssl',
    ...         'mingw-w64-x86_64-readline',
    ...     ],
    ...     'makedepends': ['mingw-w64-x86_64-tcl'],
    ... }
    >>> result = parse_pkginfo(text)
    >>> assert expected == result, result


    For example, using a .SRCINFO text:

    >>> text = '''# Generated by makepkg 5.2.1
    ... # Mon May 25 08:54:20 UTC 2020
    ... pkgbase = mingw-w64-libarchive
    ...     pkgdesc = Multi-format archive and compression library (mingw-w64)
    ...     pkgver = 3.4.3
    ...     pkgrel = 1
    ...     url = https://www.libarchive.org/
    ...     arch = any
    ...     license = BSD
    ...     makedepends = mingw-w64-x86_64-gcc
    ...     makedepends = mingw-w64-x86_64-pkg-config
    ...     depends = mingw-w64-x86_64-gcc-libs
    ...     depends = mingw-w64-x86_64-zstd
    ...     options = !libtool
    ...     options = strip
    ...     source = libarchive-3.4.3.tar.gz::https://libarchive.org/downloads/libarchive-3.4.3.tar.gz
    ...     source = 0001-libarchive-3.3.3-bcrypt-fix.patch
    ...     sha256sums = 19556c1c67aacdff547fd719729630444dbc7161c63eca661a310676a022bb01
    ...     sha256sums = 2c318a025029998a9389eb99ab80f733c0fcf3b4888421879f2f6b4530d7f522
    ...
    ... pkgname = mingw-w64-x86_64-libarchive'''
    >>> expected = {'base': 'mingw-w64-libarchive',
    ...     'desc': 'Multi-format archive and compression library (mingw-w64)',
    ...     'version': '3.4.3', 'release': '1', 'url': 'https://www.libarchive.org/',
    ...     'arch': 'any', 'licenses': ['BSD'],
    ...     'makedepends': ['mingw-w64-x86_64-gcc', 'mingw-w64-x86_64-pkg-config'],
    ...     'depends': ['mingw-w64-x86_64-gcc-libs', 'mingw-w64-x86_64-zstd'],
    ...     'options': ['!libtool', 'strip'],
    ...     'source': [
    ...         'libarchive-3.4.3.tar.gz::https://libarchive.org/downloads/libarchive-3.4.3.tar.gz',
    ...         '0001-libarchive-3.3.3-bcrypt-fix.patch'
    ...      ],
    ...     'sha256sums': [
    ...          '19556c1c67aacdff547fd719729630444dbc7161c63eca661a310676a022bb01',
    ...         '2c318a025029998a9389eb99ab80f733c0fcf3b4888421879f2f6b4530d7f522'],
    ...     'name': 'mingw-w64-x86_64-libarchive'
    ... }
    >>> result = parse_pkginfo(text)
    >>> assert expected == result, result


    And another .SRCINFO example with a release and epoch::

    >>> text = ''' # Generated by makepkg 5.2.1
    ... # Sat May  9 19:53:19 UTC 2020
    ... pkgbase = mingw-w64-libspiro
    ...     pkgdesc = Simplifies the drawing of beautiful curves (mingw-w64)
    ...     pkgver = 20200505
    ...     pkgrel = 1
    ...     epoch = 1
    ...     url = https://libspiro.sourceforge.io/
    ...     arch = any
    ...     license = GPL
    ...     makedepends = mingw-w64-x86_64-gcc
    ...     makedepends = mingw-w64-x86_64-pkg-config
    ...     options = staticlibs
    ...     options = strip
    ...     source = libspiro-20200505.tar.gz::https://github.com/fontforge/libspiro/archive/20200505.tar.gz
    ...     sha256sums = 00be530b5c0ea9274baadf
    ...
    ... pkgname = mingw-w64-x86_64-libspiro'''
    >>> expected = {
    ...     'base': 'mingw-w64-libspiro',
    ...     'desc': 'Simplifies the drawing of beautiful curves (mingw-w64)',
    ...     'version': '20200505',
    ...     'release': '1',
    ...     'epoch': '1',
    ...     'url': 'https://libspiro.sourceforge.io/',
    ...     'arch': 'any',
    ...     'licenses': ['GPL'],
    ...     'makedepends': ['mingw-w64-x86_64-gcc', 'mingw-w64-x86_64-pkg-config'],
    ...     'options': ['staticlibs', 'strip'],
    ...     'source': ['libspiro-20200505.tar.gz::https://github.com/fontforge/libspiro/archive/20200505.tar.gz'],
    ...     'sha256sums': ['00be530b5c0ea9274baadf'],
    ...     'name': 'mingw-w64-x86_64-libspiro'}
    >>> result = parse_pkginfo(text)
    >>> assert expected == result, result
    """

    lines = text.splitlines()

    pkginfo = {}
    for line in lines:
        line = line.strip()
        if not line or line.startswith('#'):
            continue

        key, _, value = line.partition('=')
        key = key.strip()
        value = value.strip()

        existing_value = pkginfo.get(key)

        if existing_value:
            if not string_list_fields or (string_list_fields and key in string_list_fields):
                # we treat this field as a list
                if isinstance(existing_value, list):
                    pkginfo[key].append(value)
                else:
                    pkginfo[key] = [existing_value, value]
                continue
            else:
                raise Exception(
                    f'Multiple values but key is not a multivalue key: '
                    f'{key} = {existing_value} and {value}')

        if key in string_list_fields:
            value = [value]
        pkginfo[key] = value

    return normalize_package_data_keys(pkginfo)


PACKAGE_DATA_KEYS_MAPPING = {
    # desc_keys_mapping
    '%NAME%': 'name',
    '%ARCH%': 'arch',
    '%VERSION%': 'version',
    '%FILENAME%': 'file_name',
    '%SHA256SUM%': 'sha256',
    '%DESC%': 'desc',
    '%GROUPS%': 'groups',
    '%LICENSE%': 'licenses',
    '%FILES%': 'files',
    '%DEPENDS%': 'depends',
    '%PROVIDES%': 'provides',
    '%CONFLICTS%': 'conflicts',
    '%REPLACES%': 'replaces',
    '%OPTDEPENDS%': 'optdepends',
    '%MAKEDEPENDS%': 'makedepends',
    '%CHECKDEPENDS%': 'checkdepends',
    # pkginfo_keys_mapping
    'pkgname': 'name',
    'pkgbase': 'base',
    'pkgver': 'version',
    'pkgrel': 'release',
    'pkgdesc': 'desc',
    'filename': 'file_name',
    'group': 'groups',
    'license': 'licenses',
    'depend': 'depends',
    'optdepend': 'optdepends',
    'makedepend': 'makedepends',
    'checkdepend': 'checkdepends',
    'conflict': 'conflicts',
    }


def normalize_package_data_keys(data, translate=PACKAGE_DATA_KEYS_MAPPING):
    """
    Given a mapping of {name:value} of package data (from a desc or .PKGINFO
    file) return a new mapping with normalized names.
    """
    new_data = {}
    for old_key, value in data.items():
        new_key = translate.get(old_key)
        if new_key:
            new_data[new_key] = value
        else:
            new_data[old_key] = value
    return new_data

################################################################################
# version comparison to make version sortable and find the latest version
################################################################################


def split_evr(version):
    """
    Return a tuple of epoch, version, release from a version string
    """
    if '~' in version:
        epoch, version = version.split('~', 1)
    else:
        epoch, version = ('0', version)

    release = None
    if '-' in version:
        version, release = version.rsplit('-', 1)
    else:
        version, release = (version, None)

    return epoch, version, release


def vercmp(version1, version2):
    """
    Compare two versions usig the same logic as cmp()
    """

    def cmp(a: int, b: int):
        return (a > b) - (a < b)

    digit, alpha, other = range(3)

    def get_char_type(c):
        assert c
        if c.isdigit():
            return digit
        elif c.isalpha():
            return alpha
        else:
            return other

    def parse(version):
        """
        Parse a version in its comparable parts
        """
        parts = []
        seps = 0
        current = ''
        for char in version:
            if get_char_type(char) == other:
                if current:
                    parts.append((seps, current))
                    current = ''
                seps += 1
            else:
                if not current:
                    current += char
                else:
                    if get_char_type(char) == get_char_type(current):
                        current += char
                    else:
                        parts.append((seps, current))
                        current = char

        parts.append((seps, current or None))

        return parts

    def rpmvercmp(version1, version2):
        """
        Compare versions using the rpm procedure.
        """
        parts1 = parse(version1)
        parts2 = parse(version2)
        aligned_parts = zip_longest(parts1, parts2, fillvalue=(None, None))
        for (s1, p1), (s2, p2) in aligned_parts:

            if s1 is not None and s2 is not None:
                ret = cmp(s1, s2)
                if ret != 0:
                    return ret

            if p1 is None and p2 is None:
                return 0

            if p1 is None:
                if get_char_type(p2) == alpha:
                    return 1
                return -1

            elif p2 is None:
                if get_char_type(p1) == alpha:
                    return -1
                return 1

            t1 = get_char_type(p1)
            t2 = get_char_type(p2)
            if t1 != t2:
                if t1 == digit:
                    return 1
                elif t2 == digit:
                    return -1
            elif t1 == digit:
                ret = cmp(int(p1), int(p2))
                if ret != 0:
                    return ret
            elif t1 == alpha:
                ret = cmp(p1, p2)
                if ret != 0:
                    return ret

        return 0

    epoch1, version1, release1 = split_evr(version1)
    epoch2, version2, release2 = split_evr(version2)

    ret = rpmvercmp(epoch1, epoch2)
    if ret == 0:
        ret = rpmvercmp(version1, version2)
        if ret == 0 and release1 is not None and release2 is not None:
            ret = rpmvercmp(release1, release2)

    return ret


# this is a key function usable in .sort() and sorted()
version_sort_key = functools.cmp_to_key(vercmp)

################################################################################
# Process and install packages in plugins
################################################################################


def install_files(extracted_dir, install_dir, real_name, copies=None):
    """
    Install libraries and licenses from the extracted_dir
    - lib dir files are installed in install_dir/lib
    - share/licenses dir files are installed in install_dir/licenses
    - share/docs dir files are installed in install_dir/docs
    """
    # map  of src to dst
    # note: the directories MUST end with a /
    copies = dict(copies)

    # also keep .BUILDINFO .PKGINFO under the licenses
    copies['.BUILDINFO'] = f'licenses/{real_name}/.BUILDINFO'
    copies['.PKGINFO'] = f'licenses/{real_name}/.PKGINFO'

    if TRACE: print('Installing with:', copies)

    for src, dst in copies.items():
        isdir = dst.endswith('/')
        src = os.path.join(extracted_dir, src)
        dst = os.path.join(install_dir, dst)
        if os.path.exists(src):
            if TRACE: print('copying:', src, dst)
            if os.path.isdir(src):
                if TRACE_INSTALL:
                    print('Installing:', src, 'to:', dst)
                copy_tree(src, dst)
            else:
                parent = os.path.dirname(dst)
                os.makedirs(parent, exist_ok=True)
                if isdir:
                    os.makedirs(dst, exist_ok=True)
                shutil.copy2(src, dst)
                if TRACE_INSTALL:
                    print('Installing:', src, 'to:', dst)


def check_installed_files(install_dir, copies, package):
    """
    Verifies that all the `copies` operations for Package `package` took place with
    all files present in `install_dir`
    """
    missing = []
    for src, dst in copies.items():
        src_isdir = src.endswith('/')
        dst_isdir = dst.endswith('/')
        dst_loc = os.path.join(install_dir, dst)

        if dst_isdir and not src_isdir:
            # file to dir
            file_name = os.path.basename(src)
            dst_loc = os.path.join(dst_loc, file_name)
            if not os.path.exists(dst_loc):
                missing.append(dst_loc)
            continue
        if dst_isdir and src_isdir:
            # dir to dir
            if not os.path.exists(dst_loc):
                missing.append(dst_loc)
            else:
                if not os.listdir(dst_loc):
                    missing.append(dst_loc)
            continue
        if not dst_isdir:
            # file to file
            if not os.path.exists(dst_loc):
                missing.append(dst_loc)
            continue

        if src_isdir and not dst_isdir:
            # dir to file: illegal
            raise Exception(f'Illegal copy from: {src} to {dst}.')
            continue

    if missing:
        missing = '\n'.join(missing)
        raise Exception(f'These files were not installed for {package}:\n{missing}')


def fetch_and_update_source_package(binary_package, repo, src_cache_dir, ident=3):
    """
    Given a binary_package and repo, fetch the sources to `src_cache_dir`. Also
    update the repo with the newest source_package data from .SRCINFO. Return
    the location where the source_package archive was fetched and the
    SourcePackage object.
    """

    if not binary_package.source_package_name:
        raise Exception(f'{binary_package} is missing required "source_package_name"')

    source_package = repo.get_source_package(
        name=binary_package.source_package_name,
        version=binary_package.version,
    )

    fetched_loc = shared_utils.fetch_file(
        url=binary_package.source_package.download_url,
        dir_location=src_cache_dir,
        ident=ident,
    )

    extracted_source_dir = shared_utils.extract_in_place(fetched_loc)
    srcinfo_loc = os.path.join(extracted_source_dir, '.SRCINFO')
    source_package.update_with_info(srcinfo_loc)

    # cleanup
    shutil.rmtree(extracted_source_dir, ignore_errors=False)
    return fetched_loc, source_package


def verify_package(package, fetched_loc):
    """
    Verify a package archive integrity if possible
    """
    if hasattr(package, 'sha256'):
        shared_utils.verify(fetched_loc, package.sha256)


def setup_dirs(install_dir, thirdparty_dir, base_dir, source_plugins_dir, deletes):
    """
    Setup environment: create or clean target directories.
    """
    # create cache directories
    bin_cache_dir = os.path.join(CACHE_DIR, 'bin')
    src_cache_dir = os.path.join(CACHE_DIR, 'src')

    os.makedirs(bin_cache_dir, exist_ok=True)
    os.makedirs(src_cache_dir, exist_ok=True)

    # cleanup deletable directories
    for deletable in deletes:
        deletable = os.path.join(install_dir, deletable)
        if os.path.exists(deletable):
            if os.path.isdir(deletable):
                shutil.rmtree(deletable, ignore_errors=False)
            else:
                os.remove(deletable)

    # create AND cleanup
    os.makedirs(thirdparty_dir, exist_ok=True)
    for srcf in os.listdir(thirdparty_dir):
        os.remove(os.path.join(thirdparty_dir, srcf))

    # create AND cleanup these too:
    base_dir_name = os.path.basename(base_dir)
    saved_sources_dir = os.path.join(source_plugins_dir, base_dir_name)
    if os.path.exists(saved_sources_dir):
        shutil.rmtree(saved_sources_dir, ignore_errors=False)

    return bin_cache_dir, src_cache_dir, saved_sources_dir


def process_package(
    binary_package,
    repo,
    copies,
    bin_cache_dir,
    src_cache_dir,
    install_dir,
    thirdparty_dir,
    ident=1,
):
    """
    Process a binary package end to end.
    """
    # fetch, verify, extract and update package. install files
    fetched_binary_loc = shared_utils.fetch_file(
        url=binary_package.download_url, dir_location=bin_cache_dir, ident=ident)

    verify_package(package=binary_package, fetched_loc=fetched_binary_loc)

    extracted_dir = shared_utils.extract_in_place(fetched_binary_loc)

    pkginfo_loc = os.path.join(extracted_dir, '.PKGINFO')
    binary_package.update_with_info(pkginfo_loc)

    install_files(
        extracted_dir=extracted_dir, install_dir=install_dir,
        real_name=binary_package.real_name, copies=copies)

    # fetch sources and update metadata
    fetch_source_loc, source_package = fetch_and_update_source_package(
        package=binary_package, repo=repo, src_cache_dir=src_cache_dir, ident=ident + 2)

    # save a copy in the plugin thirdparty with an ABOUT file
    shutil.copy2(src=fetch_source_loc, dst=thirdparty_dir)
    shared_utils.create_about_file(
        target_directory=thirdparty_dir, **source_package.to_about())

    return extracted_dir


def update_package(
    name,
    version=None,
    repo_name='mingw64',
):
    """
    Fetch a `package` with `name` and optional `version` from `repo` and save
    its sources and binaries as well as its full dependency tree sources and
    binaries. Then delete the `deletes` list of paths under `install_dir`.
    Then install in `install_dir` using `copies` {from:to} copy operations.
    Finally copy sources to a source plugin and create ABOUT files for
    the included thirdparty.
    """
    # get presets
    presets = PRESETS.get((name, repo_name,), {})
    version = version or presets.get('version')

    # setup base directories
    install_dir = presets['install_dir']
    deletes = presets['deletes']
    copies = presets['copies']

    # used for sources redistribution
    base_dir = presets['base_dir']
    thirdparty_dir = presets['thirdparty_dir']
    source_plugins_dir = presets['source_plugins_dir']

    print('Updating package:', name, '@', version, 'from repo:', repo_name)

    bin_cache_dir, src_cache_dir, saved_sources_dir = setup_dirs(
        install_dir, thirdparty_dir, base_dir, source_plugins_dir, deletes,
    )

    # populate our remote index with the list of known source and binary packages
    repo = REPOSITORIES[repo_name]
    repo.populate_package_from_index_urls()

    root_package = repo.get_binary_package(name, version)
    assert root_package, f'Unable to find package: {name} @ {version}'

    if TRACE_FETCH: print(f'Processing package: {root_package}')
    extracted_locs = []

    extracted_loc = process_package(
        root_package, repo, copies,
        bin_cache_dir, src_cache_dir,
        install_dir, thirdparty_dir,
        indent=1,
    )

    extracted_locs.append(extracted_loc)

    if TRACE_FETCH: print(f'Fetching dependencies for: {root_package}')
    for dep in root_package.get_unique_dependencies(repo):

        if TRACE_FETCH: print(f'\n  -> Fetching dependency: {dep}')
        extracted_loc = process_package(
            dep, repo, copies,
            bin_cache_dir, src_cache_dir,
            install_dir, thirdparty_dir,
            indent=3,
        )

    # finally make a copy of each plugins with their sources on our "sdist"
    copy_tree(base_dir, saved_sources_dir)

    check_installed_files(install_dir, copies, root_package)
    # finally cleanup after thyself, removing extracted locations
    for loc in extracted_locs:
        shutil.rmtree(loc, False)


def main(argv):
    update_package(name='mingw-w64-x86_64-libarchive', version='3.4.3-1', repo_name='mingw64')
    update_package(name='mingw-w64-x86_64-file', version='5.39-1', repo_name='mingw64')


PRESETS = {
    ('mingw-w64-x86_64-libarchive', 'mingw64') : {
        'version': '3.4.3-1',
        'deletes': ['licenses', 'lib'],
        'install_dir': 'builtins/extractcode_libarchive-win64/src/extractcode_libarchive',

        'base_dir': 'builtins/extractcode_libarchive-win64',
        'thirdparty_dir': 'builtins/extractcode_libarchive-win64/thirdparty',

        'source_plugins_dir': 'builtins/extractcode_libarchive-sources',

        'copies': {
            'mingw64/share/licenses/': 'licenses/',
            'mingw64/bin/libarchive-13.dll': 'lib/libarchive.dll',
            'mingw64/include/archive.h': 'licenses/libarchive/libarchive.LICENSE',

            # other libs
            'mingw64/bin/libbz2-1.dll': 'lib/libbz2-1.dll',

            'mingw64/bin/libffi-7.dll': 'lib/libffi-7.dll',

            'mingw64/bin/libtasn1-6.dll': 'lib/libtasn1-6.dll',

            'mingw64/bin/liblz4.dll': 'lib/liblz4.dll',
            'mingw64/include/lz4frame_static.h': 'licenses/lz4/lz4.LICENSE',

            'mingw64/include/mpc.h': 'licenses/mpc/mpc.LICENSE',

            'mingw64/include/mpfr.h': 'licenses/mpfr/mpfr.LICENSE',
            'mingw64/share/doc/mpfr/COPYING.LESSER': 'licenses/mpfr/',
            'mingw64/share/doc/mpfr/AUTHORS': 'licenses/mpfr/',
            'mingw64/share/doc/mpfr/COPYING': 'licenses/mpfr/',
            'mingw64/share/doc/mpfr/COPYING.LESSER': 'licenses/mpfr/',

            'mingw64/bin/libhogweed-6.dll': 'lib/libhogweed-6.dll',
            'mingw64/bin/libnettle-8.dll': 'lib/libnettle-8.dll',
            'mingw64/include/nettle/nettle-meta.h': 'licenses/nettle/nettle.LICENSE',

            # openssl
            'mingw64/bin/libcrypto-1_1-x64.dll': 'lib/libcrypto-1_1-x64.dll',
            'mingw64/bin/libssl-1_1-x64.dll': 'lib/libssl-1_1-x64.dll',

            # p11-kit
            'mingw64/bin/libp11-kit-0.dll': 'lib/libp11-kit-0.dll',
            'mingw64/include/p11-kit-1/p11-kit/p11-kit.h': 'licenses/p11-kit/p11-kit.LICENSE',

            # xz/lzma
            'mingw64/bin/liblzma-5.dll': 'lib/liblzma-5.dll',

            'mingw64/bin/libzstd.dll': 'lib/libzstd.dll',

            # zlib
            'mingw64/bin/zlib1.dll': 'lib/zlib1.dll',

            ######### standard libs
            # expat
            'mingw64/bin/libexpat-1.dll': 'lib/libexpat-1.dll',

            # gcc libs
            'mingw64/bin/libatomic-1.dll': 'lib/libatomic-1.dll',
            'mingw64/bin/libgcc_s_seh-1.dll': 'lib/libgcc_s_seh-1.dll',
            'mingw64/bin/libgomp-1.dll': 'lib/libgomp-1.dll',
            'mingw64/bin/libquadmath-0.dll': 'lib/libquadmath-0.dll',
            'mingw64/bin/libssp-0.dll': 'lib/libssp-0.dll',
            'mingw64/bin/libstdc++-6.dll': 'lib/libstdc++-6.dll',

            # gettext
            'mingw64/bin/libasprintf-0.dll': 'lib/libasprintf-0.dll',
            'mingw64/bin/libgettextlib-0-19-8-1.dll': 'lib/libgettextlib-0-19-8-1.dll',
            'mingw64/bin/libgettextpo-0.dll': 'lib/libgettextpo-0.dll',
            'mingw64/bin/libgettextsrc-0-19-8-1.dll': 'lib/libgettextsrc-0-19-8-1.dll',
            'mingw64/bin/libintl-8.dll': 'lib/libintl-8.dll',

            # gmp
            'mingw64/bin/libgmp-10.dll': 'lib/libgmp-10.dll',
            'mingw64/bin/libgmpxx-4.dll': 'lib/libgmpxx-4.dll',
            'mingw64/include/gmp.h': 'licenses/gmp/gmp.LICENSE',

            # iconv
            'mingw64/bin/libcharset-1.dll': 'lib/libcharset-1.dll',
            'mingw64/bin/libiconv-2.dll': 'lib/libiconv-2.dll',

            # tre and systre
            'mingw64/bin/libsystre-0.dll': 'lib/libsystre-0.dll',
            'mingw64/bin/libtre-5.dll': 'lib/libtre-5.dll',

            # libwinpthread
            'mingw64/bin/libwinpthread-1.dll': 'lib/libwinpthread-1.dll',
        },
    },
    ('mingw-w64-x86_64-file', 'mingw64') : {
        'version': '5.39-1',
        'deletes': ['licenses', 'lib', 'data'],
        'install_dir': 'builtins/typecode_libmagic-win64/src/typecode_libmagic',

        'base_dir': 'builtins/typecode_libmagic-win64',
        'thirdparty_dir': 'builtins/typecode_libmagic-win64/thirdparty',
        'source_plugins_dir': 'builtins/typecode_libmagic-sources',

        'copies': {
            'mingw64/share/licenses/': 'licenses/',
            'mingw64/bin/libmagic-1.dll': 'lib/libmagic.dll',
            'mingw64/share/misc/magic.mgc': 'data/magic.mgc',

            'mingw64/bin/libbz2-1.dll': 'lib/libbz2-1.dll',
            'mingw64/bin/liblzma-5.dll': 'lib/liblzma-5.dll',
            'mingw64/bin/zlib1.dll': 'lib/zlib1.dll',

            ######### standard libs
            # expat
            'mingw64/bin/libexpat-1.dll': 'lib/libexpat-1.dll',

            # gcc libs
            'mingw64/bin/libatomic-1.dll': 'lib/libatomic-1.dll',
            'mingw64/bin/libgcc_s_seh-1.dll': 'lib/libgcc_s_seh-1.dll',
            'mingw64/bin/libgomp-1.dll': 'lib/libgomp-1.dll',
            'mingw64/bin/libquadmath-0.dll': 'lib/libquadmath-0.dll',
            'mingw64/bin/libssp-0.dll': 'lib/libssp-0.dll',
            'mingw64/bin/libstdc++-6.dll': 'lib/libstdc++-6.dll',

            # gettext
            'mingw64/bin/libasprintf-0.dll': 'lib/libasprintf-0.dll',
            'mingw64/bin/libgettextlib-0-19-8-1.dll': 'lib/libgettextlib-0-19-8-1.dll',
            'mingw64/bin/libgettextpo-0.dll': 'lib/libgettextpo-0.dll',
            'mingw64/bin/libgettextsrc-0-19-8-1.dll': 'lib/libgettextsrc-0-19-8-1.dll',
            'mingw64/bin/libintl-8.dll': 'lib/libintl-8.dll',

            # gmp
            'mingw64/bin/libgmp-10.dll': 'lib/libgmp-10.dll',
            'mingw64/bin/libgmpxx-4.dll': 'lib/libgmpxx-4.dll',
            'mingw64/include/gmp.h': 'licenses/gmp/gmp.LICENSE',

            # iconv
            'mingw64/bin/libcharset-1.dll': 'lib/libcharset-1.dll',
            'mingw64/bin/libiconv-2.dll': 'lib/libiconv-2.dll',

            # tre and systre
            'mingw64/bin/libsystre-0.dll': 'lib/libsystre-0.dll',
            'mingw64/bin/libtre-5.dll': 'lib/libtre-5.dll',

            # libwinpthread
            'mingw64/bin/libwinpthread-1.dll': 'lib/libwinpthread-1.dll',
        }
    },
    ('mingw-w64-x86_64-universal-ctags-git', 'mingw64'): {
        'version': 'r7253.7492b90e-1',
        'deletes': ['licenses', 'bin', 'lib', ],
        'install_dir': 'binary-analysis/scancode-ctags-win64/src/scancode_ctags',

        'base_dir': 'binary-analysis/scancode-ctags-win64',
        'thirdparty_dir': 'binary-analysis/scancode-ctags-win64/thirdparty',
        'source_plugins_dir': 'binary-analysis/scancode-ctags-sources',

        'copies': {
            'mingw64/share/licenses/': 'licenses/',
            'mingw64/bin/ctags.exe': 'bin/ctags.exe',

            'mingw64/bin/libjansson-4.dll': 'bin/libjansson-4.dll',
            'mingw64/bin/liblzma-5.dll': 'bin/liblzma-5.dll',
            'mingw64/bin/libxml2-2.dll': 'bin/libxml2-2.dll',
            'mingw64/bin/libyaml-0-2.dll': 'bin/libyaml-0-2.dll',
            'mingw64/bin/xml2-config': 'bin/xml2-config',
            'mingw64/bin/zlib1.dll': 'bin/zlib1.dll',

            'mingw64/bin/libasprintf-0.dll': 'bin/libasprintf-0.dll',
            'mingw64/bin/libatomic-1.dll': 'bin/libatomic-1.dll',
            'mingw64/bin/libcharset-1.dll': 'bin/libcharset-1.dll',
            'mingw64/bin/libexpat-1.dll': 'bin/libexpat-1.dll',
            'mingw64/bin/libgcc_s_seh-1.dll': 'bin/libgcc_s_seh-1.dll',
            'mingw64/bin/libgettextlib-0-19-8-1.dll': 'bin/libgettextlib-0-19-8-1.dll',
            'mingw64/bin/libgettextpo-0.dll': 'bin/libgettextpo-0.dll',
            'mingw64/bin/libgettextsrc-0-19-8-1.dll': 'bin/libgettextsrc-0-19-8-1.dll',
            'mingw64/bin/libgmp-10.dll': 'bin/libgmp-10.dll',
            'mingw64/bin/libgmpxx-4.dll': 'bin/libgmpxx-4.dll',
            'mingw64/bin/libgomp-1.dll': 'bin/libgomp-1.dll',
            'mingw64/bin/libiconv-2.dll': 'bin/libiconv-2.dll',
            'mingw64/bin/libintl-8.dll': 'bin/libintl-8.dll',
            'mingw64/bin/libquadmath-0.dll': 'bin/libquadmath-0.dll',
            'mingw64/bin/libssp-0.dll': 'bin/libssp-0.dll',
            'mingw64/bin/libstdc++-6.dll': 'bin/libstdc++-6.dll',
            'mingw64/bin/libwinpthread-1.dll': 'bin/libwinpthread-1.dll',

        },
    },
    ('mingw-w64-cross-binutils', 'msys64'): {
        'version': '2.34-1',
        'install_dir': 'binary-analysis/scancode-readelf-win64/src/scancode_readelf',
        'deletes': ['licenses', 'lib', 'bin', 'doc'],

        'base_dir': 'binary-analysis/scancode-readelf-win64',
        'thirdparty_dir': 'binary-analysis/scancode-readelf-win64/thirdparty',
        'source_plugins_dir': 'binary-analysis/scancode-readelf-sources',

        'copies': {
#            'usr/share/licenses': 'licenses',
        },
    },
}

if __name__ == '__main__':
    sys.exit(main(sys.argv))
